
#include <cmath>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include "formant_shift.h"
#include "utils.h"

using namespace ubnt;

/** Filter out high frequency vibration in spectrum by using cepstrum
 * @param inSpectrum The spectrum of signal generated by pffft ordered transform
 * @param outSpectrum The smoothed spectrum which is desired
 * @param frameSize The length of inSpectrum and outSpectrum buffer
 * 
 * @return NULL No return value
 */
void FormantShift::spectralSmooth(float *inSpectrum, float *outSpectrum, unsigned int frameSize) {
    logSpectrum[0] = logf(inSpectrum[0]);
    logSpectrum[1] = logf(inSpectrum[1]);
    for (unsigned int i = 2; i < frameSize; i+=2) {
        logSpectrum[i] = log(inSpectrum[i]);
        logSpectrum[i + 1] = 0.0f;
    }
    fft.ifftOrder(logSpectrum, cepstrum, frameSize);

    // Cut high-frequency part in cepstrum domain
    const unsigned int fCutIndex = 
        static_cast<unsigned int>(round(static_cast<float>(frameSize) * spectralSmoothRatio));
    memset(cepstrum + fCutIndex, 0, sizeof(float) * (frameSize - fCutIndex*2 + 1));
    fft.fftOrder(cepstrum, logSpectrum, frameSize);

    // Calculate otuput spectrum by exponential of logSpectrum
    outSpectrum[0] = exp(logSpectrum[0]);
    outSpectrum[1] = exp(logSpectrum[1]);
    for (unsigned int i = 2; i < frameSize; i+=2) {
        outSpectrum[i] = exp(logSpectrum[i]);
        outSpectrum[i + 1] = 0.0f;
    }
    
    return;
}

void FormantShift::setShiftTone(float shiftTone) {
    this->shiftTone = shiftTone;
}

float FormantShift::getShiftTone() {
    return this->shiftTone;
}

void FormantShift::init() {
    if (bufferSize == 0U) return;
    processSize = bufferSize * 2;

    fft.init(processSize, Pffft::Transform::REAL);

    // Buffer for spectrum smoothing
    cepstrum = new float[processSize]();
    logSpectrum = new float[processSize]();

    oriFormantInterpo = new FormantInterpolate(processSize);

    // Buffer for formant shift
    inBuffer = new float[processSize]();
    inFrequency = new float[processSize]();
    inSpectrum = new float[processSize]();
    oriBuffer = new float[processSize]();
    oriSpectrum = new float[processSize]();
    outFrequency = new float[processSize]();
    outBuffer = new float[processSize]();

    inOLA = new OverlapAdd(bufferSize, 
                            OverlapAdd::WindowType::HANNING,
                            OverlapAdd::WindowType::NONE);
    oriOLA = new OverlapAdd(bufferSize, 
                            OverlapAdd::WindowType::HANNING,
                            OverlapAdd::WindowType::NONE);
}

void FormantShift::release() {
    fft.release();

    // Buffer for spectrum smoothing
    freeBuffer(&cepstrum);
    freeBuffer(&logSpectrum);

    // Buffer for formant shift
    freeBuffer(&inBuffer);
    freeBuffer(&inFrequency);
    freeBuffer(&inSpectrum);
    freeBuffer(&oriBuffer);
    freeBuffer(&oriSpectrum);
    freeBuffer(&outFrequency);
    freeBuffer(&outBuffer);

    if (oriFormantInterpo != nullptr) {
        delete oriFormantInterpo;
        oriFormantInterpo = nullptr;
    }
    
    if (inOLA != nullptr) {
        delete inOLA; inOLA = nullptr;
    }

    if (oriOLA != nullptr) {
        delete oriOLA; oriOLA = nullptr;
    }
}

int FormantShift::process(float* in, float *ori, float* out, unsigned int numSample) {
    // If input buffer size changes, the corresponding fft size and buffer
    // should also be reallocated.
    if (numSample != bufferSize) {
        bufferSize = numSample;
        release(); init();
    }

    // Ring buffer process. Put buffer in and get windowed buffer out
    // with twice the buffer length.
    inOLA->setInput(in, bufferSize);
    inOLA->getInput(inBuffer, processSize);
    oriOLA->setInput(ori, bufferSize);
    oriOLA->getInput(oriBuffer, processSize);

    // Calculate frequency & spectrum of inBuffer(pitch shifted signal) and oriBuffer(original signal)
    fft.fftOrder(inBuffer, inFrequency, processSize);
    fft.fftOrder(oriBuffer, oriSpectrum, processSize);

    // Get spectrum from frequency
    Pffft::getSpectrum(inFrequency, inSpectrum, processSize);
    Pffft::getSpectrum(oriSpectrum, oriSpectrum, processSize);

    // Get smoothed formant from spectrum, the output also saved in spectrum variables
    spectralSmooth(inSpectrum, inSpectrum, processSize);
    spectralSmooth(oriSpectrum, oriSpectrum, processSize);
    oriFormantInterpo->process(oriSpectrum, shiftTone, processSize);

    // Correct formant of the pitch shifted signal by morphing it into the formant of original signal
    outFrequency[0] = inFrequency[0] * oriSpectrum[0] / std::max<float>(inSpectrum[0], 0.000001f);
    outFrequency[1] = inFrequency[1] * oriSpectrum[1] / std::max<float>(inSpectrum[1], 0.000001f);
    for (unsigned int fIdx = 2; fIdx < processSize; fIdx += 2) {
        const float coef = oriSpectrum[fIdx] / std::max<float>(inSpectrum[fIdx], 0.000001f);
        outFrequency[fIdx] = inFrequency[fIdx] * coef;
        outFrequency[fIdx + 1] = inFrequency[fIdx + 1] * coef; 
    }

    // Copy the previous half output, which is saved at the later half of outBuffer
    fft.ifftOrder(outFrequency, outBuffer, processSize);
    inOLA->setOutput(outBuffer, processSize);
    inOLA->getOutput(out, bufferSize);

    return bufferSize;
}